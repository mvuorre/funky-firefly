---
title: "Simulations"
output: 
  html_document:
    self_contained: true
date: "2023-03-28"
---

This is a notebook for additional and supplementary simulations.

```{r setup1, include=FALSE}
library(knitr)
opts_chunk$set(
  echo = TRUE,
  message = FALSE
)
```


```{r setup2}
library(MASS)
library(patchwork)
library(parameters)
library(lme4)
library(brms)
library(tidyverse)

# Plotting options
theme_set(
  theme_linedraw(base_size = 10) +
    theme(
      strip.background = element_rect(fill = "gray90", color = "gray90"),
      strip.text = element_text(color = "black", hjust = 0),
      panel.grid = element_blank()
    )
)

# HMC and parallel computation options
MAX_CORES <- as.numeric(Sys.getenv("MAX_CORES"))
if (is.na(MAX_CORES)) MAX_CORES <- parallelly::availableCores(logical = FALSE)
if (require(cmdstanr)) {
  options(
    brms.backend = "cmdstanr", 
    brms.threads = MAX_CORES %/% 4,
    mc.cores = MAX_CORES
  )
}
```

# Simulation 1

>Conclusions:   
1. Nowhere in the brms model do we specify an outcome model for X. Yet the X intercept (and its standard deviation) is estimated OK.  
2. Y intercept is slightly less biased with latent mean centering (?)   
3. The within-cluster effect of X is biased downward with latent centering, while the between-cluster effect is upward biased.  
4. The between-person SDs are all over the place.   

This is the most basic model where this should work. If it doesn't---back to the drawing board.

We have two variables, X and Y, repeatedly observed I times for J participants. We model X as simply a random gaussian variable with person-specific intercepts. We then model Y with person specific intercepts, person-specific slopes of (X - person-specific mean of X) and a common slope of (person-specific mean of X). i.e.:

$$
\begin{align*}
x_{ij} &\sim \operatorname{Normal}(\beta_{1j}, \sigma^2_x) \\
y_{ij} &\sim \operatorname{Normal}(
\beta_{2j} +
\beta_{3j}(x_{ij} - \beta_{1j}) +
\beta_4\beta_1, 
\sigma^2_y
) \\
\begin{bmatrix} 
\beta_1 \\ \beta_2 \\ \beta_3 \\ \beta_4
\end{bmatrix} &\sim \operatorname{MVN}(
\begin{bmatrix} 
\bar{\beta}_1 \\ \bar{\beta}_2 \\ \bar{\beta}_3 \\ \bar{\beta}_4
\end{bmatrix}, \mathbf{\Sigma}) \\ \\
\Sigma &= \mathbf{SRS} \\ \\
\mathbf{S} &= \begin{bmatrix} 
\tau_{\beta_1} &0 &0 &0 \\ 
0 &\tau_{\beta_2} &0 &0\\ 
0 &0 &\tau_{\beta_3} &0 \\ 
0 &0 &0 &\tau_{\beta_4}
\end{bmatrix} \\ \\
\mathbf{R} &= 
\begin{bmatrix} 
1 &\rho_{\beta_1\beta_2} &\rho_{\beta_1\beta_3} &\rho_{\beta_1\beta_4} \\ 
\rho_{\beta_1\beta_2} &1 &\rho_{\beta_2\beta_3} &\rho_{\beta_2\beta_4} \\ 
\rho_{\beta_1\beta_3} &\rho_{\beta_2\beta_3} &1 &\rho_{\beta_3\beta_4} \\ 
\rho_{\beta_1\beta_4} &\rho_{\beta_2\beta_4} &\rho_{\beta_3\beta_4} &1 \\
\end{bmatrix}.
\end{align*}
$$

Here's code to do that. We set the values first, and J=30, I=20.

```{r}
sim1 <- function(..., n_person = 30, n_time = 20) {
  # Population level effects
  beta <- c(0, 0, .5)
  beta_4 <- -0.5
  sd <- c(1, 1, .5)
  cor <- c(0, 0, 0)
  sd_x <- 1
  sd_y <- 1
  
  # SDs and correlations to variance-covariance
  S <- diag(length(sd))
  S[lower.tri(S)] <- S[upper.tri(S)] <- cor
  S <- diag(sd) %*% S %*% diag(sd)
  
  # Person-specific deviations
  u <- mvrnorm(n_person, beta, S) %>% 
    as.data.frame() %>% 
    setNames(paste0("beta_", 1:3)) %>% 
    as_tibble() %>% 
    mutate(person = 1:n_person)
  
  # Data
  d <- u %>% 
    crossing(i = 1:n_time) %>% 
    arrange(person, i) %>% 
    mutate(
      x = rnorm(n_time, beta_1, sd_x),
      y = rnorm(n_time, beta_2 + beta_3 * (x - beta_1) + beta_4*beta_1, sd_y),
      .by = person
    ) %>% 
    mutate(xb = mean(x), xc = x - xb, .by = person)
  d
}
```

Here are plots of the data, and quick model fits. Note that the non-decomposed raw X works just fine as a predictor here.

```{r}
#| fig.width: 8
#| fig.height: 4
d1 <- sim1()

(d1 %>% 
    ggplot(aes(x, y)) +
    geom_point(shape = 1) +
    labs(subtitle = "'Total' association") +
    geom_smooth(method = "lm") |
    d1 %>% 
    summarise(x = mean(x), y = mean(y), .by = person) %>% 
    ggplot(aes(x, y)) +
    labs(x = "Xbar", y = "Ybar", subtitle = "Between-person association") +
    geom_point(shape = 1) +
    geom_smooth(method = "lm") |
    d1 %>% 
    filter(person %in% sample(unique(d1$person), 4)) %>% 
    ggplot(aes(x, y)) +
    labs(subtitle = "Within-person association") +
    geom_point(shape = 1) +
    geom_smooth(method = "lm") +
    facet_wrap("person")) &
  theme(aspect.ratio = 1)

x1 <- lmer(y ~ x + (x | person), data = d1)
parameters(x1) %>% tibble() %>% kable(digits = 2)

x2 <- lmer(y ~ xc + xb + (xc | person), data = d1)
parameters(x2) %>% tibble() %>% kable(digits = 2)
```

Try a fit

```{r}
dat <- sim1(n_person = 30, n_time = 20) %>% 
  mutate(beta11 = 0)

# With equality
model <- bf(
  y ~ beta2 + beta3*(x - beta1) + beta4*beta1,
  beta1 + beta2 + beta3 ~ 1 + (1 |i| person),
  beta4 ~ 1,
  nl = TRUE
) +
  bf(
    x ~ beta11,
    beta11 ~ 1 + (1 |i| person),
    nl = TRUE
  ) +
  nlf(beta1 ~ beta11, resp = "y") +
  gaussian() +
  set_rescor(FALSE)
p <- get_prior(model, dat) %>% 
  mutate(prior = if_else(class=="b", "normal(0, 1)", prior))
make_stancode(model, dat, prior = p, backend = "rstan")
fit <- brm(
  model,
  dat,
  prior = p,
  cores = 8, iter = 1000, threads = 2, backend = "cmdstanr"
)
summary(fit)

# Without
model2 <- bf(
  y ~ beta2 + beta3*(x - beta1) + beta4*beta1,
  beta1 + beta2 + beta3 ~ 1 + (1 |i| person),
  beta4 ~ 1,
  nl = TRUE
) +
  gaussian()
p2 <- get_prior(model2, dat) %>% 
  mutate(prior = if_else(class=="b", "normal(0, 1)", prior))

fit2 <- brm(
  model2,
  dat,
  prior = p2,
  cores = 8, iter = 1000, threads = 2, backend = "cmdstanr"
)
summary(fit2)

stancode(fit)
```


We then run this simulation 100 times, and estimate the latent variable brms model, and observed variable lmer model.

```{r}
# Save empty brms models
model1 <- bf(
  y ~ beta2 + beta3*(x - beta1) + beta4*beta1,
  beta1 + beta2 + beta3 ~ 1 + (1 |i| person),
  beta4 ~ 1,
  nl = TRUE
) +
  gaussian()
p1 <- get_prior(model1, d1) %>% 
  mutate(
    prior = case_when(
      class == "b" ~ "normal(0, 1)",
      class == "sd" ~ "student_t(7, 0, 1)",
      class == "cor" ~ "lkj(2)",
      TRUE ~ prior
    )
  )

model1_fit_empty <- brm(
  model1,
  data = d1,
  prior = p1,
  control = list(adapt_delta = 0.95),
  chains = 0,
  threads = 2,
  backend = "cmdstanr",
  file = "models/brm-simulation-model1-empty"
)

model2 <- bf(
  y ~ beta2 + beta3*(x - beta1) + beta4*beta1,
  beta1 + beta2 + beta3 ~ 1 + (1 |i| person),
  beta4 ~ 1,
  nl = TRUE
) +
  bf(
    x ~ beta11,
    beta11 ~ 1 + (1 |i| person),
    nl = TRUE
  ) +
  nlf(beta1 ~ beta11, resp = "y") +
  gaussian() +
  set_rescor(FALSE)
p2 <- get_prior(model2, d1 %>% mutate(beta11 = 0)) %>% 
  mutate(
    prior = case_when(
      class == "b" ~ "normal(0, 1)",
      class == "sd" ~ "student_t(7, 0, 1)",
      class == "cor" ~ "lkj(2)",
      TRUE ~ prior
    )
  )

model2_fit_empty <- brm(
  model2,
  d1 %>% mutate(beta11 = 0),
  prior = p2,
  control = list(adapt_delta = 0.95),
  chains = 0,
  threads = 2,
  backend = "cmdstanr",
  file = "models/brm-simulation-model2-empty"
)

# Run simulation
path <- "sims/simulation-1.rds"
if (!file.exists(path)) {
  sims <- tibble(n = 1:100) %>% 
    mutate(
      data = map(n, sim1),
      brms1 = map(
        data,
        ~update(
          model1_fit_empty, 
          newdata = .x,
          recompile = FALSE,
          control = list(adapt_delta = 0.95),
          iter = 2400,
          chains = 4,
          cores = 8,
          threads = 2,
          refresh = 0,
          backend = "cmdstanr"
        ) %>% 
          parameters(centrality = "mean", effects = "all", test = NULL) %>% 
          tibble()
      ),
      brms2 = map(
        data,
        ~update(
          model2_fit_empty, 
          newdata = .x %>% mutate(beta11 = 0),
          recompile = FALSE,
          control = list(adapt_delta = 0.95),
          iter = 2400,
          chains = 4,
          cores = 8,
          threads = 2,
          refresh = 0,
          backend = "cmdstanr"
        ) %>% 
          parameters(centrality = "mean", test = NULL) %>% 
          tibble()
      ),
      lmer = map(
        data,
        ~lmer(y ~ xc + xb + (xc | person), data = .x) %>% 
          parameters() %>% 
          tibble()
      )
    )
  saveRDS(sims, path)
} else {sims <- readRDS(path)}
```

Here are the results. For each parameter (where possible--lmer doesn't estimate the X intercept) we show the brms and lmer results. Horizontal lines represent values we specified in the simulation.

```{r}
#| fig.width: 8
#| fig.height: 4

truth <- tibble(
  beta_1 = 0,
  beta_2 = 0,
  beta_3 = .5,
  beta_4 = -.5
  # sd_1 = 1,
  # sd_2 = 1,
  # sd_3 = .5
) %>% 
  pivot_longer(everything(), names_to = "Parameter")
out <- sims %>% 
  select(-data) %>% 
  mutate(
    brms1 = map(
      brms1,
      ~mutate(
        .x,
        Parameter = case_match(
          Parameter,
          "b_beta1_Intercept" ~ "beta_1",
          "b_beta2_Intercept" ~ "beta_2",
          "b_beta3_Intercept" ~ "beta_3",
          "b_beta4_Intercept" ~ "beta_4",
          # "sd_person__beta1_Intercept" ~ "sd_1",
          # "sd_person__beta2_Intercept" ~ "sd_2",
          # "sd_person__beta3_Intercept" ~ "sd_3",
        )
      ) %>% 
        drop_na(Parameter) %>% 
        rename(Coefficient = Mean)
    ),
    brms2 = map(
      brms2,
      ~mutate(
        .x,
        Parameter = case_match(
          Parameter,
          "b_x_beta11_Intercept" ~ "beta_1",
          "b_y_beta2_Intercept" ~ "beta_2",
          "b_y_beta3_Intercept" ~ "beta_3",
          "b_y_beta4_Intercept" ~ "beta_4",
          # "sd_person__beta1_Intercept" ~ "sd_1",
          # "sd_person__beta2_Intercept" ~ "sd_2",
          # "sd_person__beta3_Intercept" ~ "sd_3",
        )
      ) %>% 
        drop_na(Parameter) %>% 
        rename(Coefficient = Mean)
    ),
    lmer = map(
      lmer,
      ~mutate(
        .x,
        Parameter = case_match(
          Parameter,
          "(Intercept)" ~ "beta_2",
          "xc" ~ "beta_3",
          "xb" ~ "beta_4",
          # "SD (Intercept)" ~ "sd_2",
          # "SD (xc)" ~ "sd_3"
        )
      ) %>% 
        drop_na(Parameter)
    )
  ) %>% 
  pivot_longer(c(brms1, brms2, lmer)) %>% 
  unnest(value)
  
out %>% 
  ggplot(aes(name, Coefficient)) +
  scale_x_discrete(
    breaks = c("brms1", "brms2", "lmer"),
    # labels = c("brms\n(latent\ncentering)", "lmer\n(observed\ncentering)")
  ) +
  scale_y_continuous(
    "Estimated coefficient"
  ) +
  geom_hline(
    data = truth,
    aes(yintercept = value),
    linewidth = .25
  ) +
  stat_summary() +
  facet_wrap(
    "Parameter", scales = "free_y", ncol = 4,
    labeller = as_labeller(
      c("beta_1" = "X Intercept",
        "beta_2" = "Y Intercept",
        "beta_3" = "Y on X (within)",
        "beta_4" = "Y on X (between)"
        # "sd_1" = "sd(X Intercept)",
        # "sd_2" = "sd(Y Intercept)",
        # "sd_3" = "sd(Y on X [within])"
      )
    )
  ) +
  theme(
    axis.title.x = element_blank(),
    aspect.ratio = 1
  )
```

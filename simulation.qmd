---
title: "Simulations"
subtitle: "Specification and simulation of brms latent means model"
authors:
  - name: Matti Vuorre
    email: mjvuorre@uvt.nl
    url: https://vuorre.com
    orcid: 0000-0001-5052-066X
    affiliation:
      - ref: 1
  - name: Joran Jongerling
    orcid: 0000-0001-5697-1381
    affiliation:
      - ref: 1
affiliations:
  - id: 1
    name: Tilburg University
execute: 
  cache: true
  error: true
format: 
  html:
    theme: materia
    toc: true
    code-fold: true
---

Here we simulate from, specify, and validate latent means models with brms.

```{r}
#| label: options

library(posterior)
library(mvtnorm)
library(cmdstanr)
library(ggdist)
library(brms)
library(tidyverse)

N_CORES <- min(parallel::detectCores(), 8)
options(
  mc.cores = N_CORES,
  brms.backend = if(require(cmdstanr)) "cmdstanr",
  brms.threads = N_CORES %/% 4
)
```

# Univariate model

The data simulation and Stan code here is based on [Joran's blog post](https://experienced-sampler.netlify.app/post/stan-hierarchical-ar/).

## Data

We first set up the data simulation.

```{r}
#' Simulate ar(1) data
#' 
#' Adapted from <https://experienced-sampler.netlify.app/post/stan-hierarchical-ar/#testing>
#'
#' @param I number of individuals
#' @param t number of time points per individual
#' @param sigma residual standard deviation of observations
#' @param alpha_hat intercept mean
#' @param alpha_scale intercept standard deviation
#' @param beta_hat ar(1) slope mean
#' @param beta_scale ar(1) slope standard deviation
#'
#' @return a list of variables to send to Stan
#'
#' @examples simulate()
simulate <- function(
    I = 50, 
    t = 25, 
    sigma = 1, 
    alpha_hat = 4, 
    alpha_scale = 1, 
    beta_hat = 0.4, 
    beta_scale = 0.1
) {
  
  # Define data
  N <- I*t # total sample size
  individual <- rep(1:I, each = t)
  time <- rep(1:t, I)
  alphas <- rnorm(I, alpha_hat, alpha_scale) # person-specific intercepts
  betas <- rnorm(I, beta_hat, beta_scale) # person-specific slopes
  for (i in 1:I) {
    # The while loop avoids non-stationary AR processes
    # See Hamilton  pg. 259
    while(betas[i] <= -1 | betas[i] >= 1) {
      betas[i] <- rnorm(1, beta_hat, beta_scale)
    }
  }
  
  # Determine first observations for everyone. The variance for this first 
  # observation is different than for the subsequent ones and so it needs to be 
  # samples separately
  IndT1 <- match(unique(individual), individual)
  
  # Determine variance at first measurement for everyone 
  # (depends on their AR-parameter)
  sigmaT1 <- rep(NA, I)
  
  for (k in 1:I) {
    sigmaT1[k] <- sigma/(1-((betas[k])^2))
  }
  
  # First create storage matrices for non-centered and centered y-scores.
  # We need centered values, because of we use person-centered values as predictors, 
  # alpha will be equal to individual means instead of individual intercepts 
  # which are less informative.
  Y <- rep(NA, N)
  Yc <- rep(NA, N)
  
  # Draw first observation for each individual first
  for (l in 1:I) {
    Y[IndT1[l]] <- rnorm(1, alphas[l], sigmaT1[l])
    Yc[IndT1[l]] <-  Y[IndT1[l]] - alphas[l]
  }
  
  # Draw subsequent observations
  for (m in 1:N) {
    # This if statement makes sure I don't try to predict a persons first 
    # observation which is impossible there is no measurement before the first 
    # observation and so no predictor values for that observation
    if (time[m]>1) {
      Y[m] <- rnorm(1, (alphas[individual[m]] + betas[individual[m]]*Yc[m-1]), sigma)
      Yc[m] <-  Y[m] - alphas[individual[m]]
    }
  }
  
  return(
    list(
      I = I,
      T = t,
      N = N,
      sigma = sigma, 
      alpha_hat = alpha_hat, 
      alpha_scale = alpha_scale, 
      beta_hat = beta_hat, 
      beta_scale = beta_scale,
      individual = individual,
      time = time,
      y = Y
    )
  )
  
}
```

The function returns a list that we can pass to Stan. It also contains the data generation parameters.

```{r}
set.seed(31121)
dat <- simulate()
glimpse(simulate())
```

### Stan model

Let us then compile and sample from the cmdstanr model

```{r}
# model <- cmdstan_model("model-ar1.stan", compile = FALSE)
# model$format(
#   canonicalize = list("deprecations"), 
#   overwrite_file = TRUE, 
#   backup = FALSE
# )
# model$compile()
model <- cmdstan_model(exe_file = "model-ar1")
path <- "models/cmdstanr-example.rds"
if (!file.exists(path)) {
post <- model$sample(
  data = dat, 
  adapt_delta = 0.99
) |> 
  as_draws_df()
saveRDS(post, path)
} else {post_cmdstanr <- readRDS(path)}
```

Visualize estimated and defined parameters

```{r}
post_cmdstanr <- post_cmdstanr |> 
  select(starts_with("beta_"), ends_with("_raw")) |> 
  rename_with(~str_remove(., "_raw"))
post_cmdstanr |> 
  pivot_longer(everything()) |> 
  ggplot(aes(value, name)) +
  scale_x_continuous(
    "Parameter value"
  ) +
  stat_histinterval(
    normalize = "xy",
    scale = 0.25, 
    size = 1
  ) +
  geom_point(
    data = as_tibble(dat) |> 
      select(sigma:beta_scale) |> 
      distinct() |> 
      pivot_longer(everything()),
    position = position_nudge(y = -0.1),
    color = "red"
  ) +
  theme(
    axis.title.y = element_blank()
  )
```

### brms

```{r}
dat <- as_tibble(dat)
dat <- dat |> 
  mutate(yt1 = lag(y), .by = individual)
head(dat)
```

We specify the model as a missing data model as follows

```{r}
bform <- bf(y | mi() ~ -1 + mi(mean) + b2*(yt1 - mi(mean))) + 
  bf(mean | mi() ~ 1 + (1 | individual))
fit <- brm(
  bform,
  data = dat
)
```

However this needs some brms syntax edits. We also change the parameter names to fit the blog post

```{r}
bform <- bf(
  y | mi() ~ 0 + mi(alpha) + beta * (yt1 - mi(alpha)),
  alpha | mi() ~ 1 + (1 | individual),
  beta ~ 1,
  nl = TRUE
)
fit <- brm(
  bform,
  data = dat
)
```

```{r}
bform <- bf(
  y ~ 0 + alpha + beta * (yt1 - alpha),
  alpha ~ 1 + (1 | individual),
  beta ~ 1 + (1 | individual),
  nl = TRUE
)
fit <- brm(
  bform,
  data = dat,
  file = "models/brm-example.rds"
)
```

Visualize estimated and defined parameters

```{r}
post_brms <- as_draws_df(fit) |> 
  select(
    alpha_hat = b_alpha_Intercept,
    alpha_scale = sd_individual__alpha_Intercept,
    beta_hat = b_beta_Intercept,
    beta_scale = sd_individual__beta_Intercept,
    sigma
  )

bind_rows(
  "Stan" = post_cmdstanr |> 
  pivot_longer(everything()),
  "brms" = post_brms |> 
  pivot_longer(everything()),
  .id = "Model"
) |> 
  mutate(side = if_else(Model == "Stan", "bottom", "top")) |> 
  ggplot(aes(value, name)) +
  scale_x_continuous(
    "Parameter value"
  ) +
  scale_color_brewer(
    palette = "Dark2",
    aesthetics = c("color", "fill")
  ) +
  stat_histinterval(
    aes(side = side, fill = Model, color = Model),
    normalize = "xy",
    scale = 0.5, 
    size = 1,
    breaks = 100,
    slab_alpha = 0.5
  ) +
  geom_point(
    data = as_tibble(dat) |> 
      select(sigma:beta_scale) |> 
      distinct() |> 
      pivot_longer(everything()),
    aes(color = "Real value", fill = "Real value"),
    size = 2
  ) +
  theme_linedraw() +
  theme(
    axis.title.y = element_blank()
  ) +
  labs(
    title = str_glue(
      "bf(y ~ 0 + alpha + beta * (yt1 - alpha),
          alpha ~ 1 + (1 | individual),
          beta ~ 1 + (1 | individual),
          nl = TRUE)"
    )
  ) +
  facet_wrap("name", scales = "free", ncol = 2)
```

# Multivariate model

Next problem is to generalize this to the multivariate situation where we have some (e.g.) X[t-1] predicting Y[t]. to be continued...

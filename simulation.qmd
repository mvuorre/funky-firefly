---
title: Simulation
subtitle: Specification and parameter recovery simulation of brms latent means model
execute: 
  error: true
  message: false
  warning: false
---

Here we simulate from, specify, and validate latent means models with brms.

```{r echo = FALSE}
#| label: options
#| output: false

library(posterior)
library(mvtnorm)
library(scales)
library(gt)
library(cmdstanr)
library(ggdist)
library(future)
library(brms)
library(tidyverse)

N_CORES <- min(parallel::detectCores(), 8)
options(
  mc.cores = N_CORES,
  brms.backend = if(require(cmdstanr)) "cmdstanr",
  brms.threads = N_CORES %/% 4
)
```

## Univariate model

The data simulation and Stan code here is based on [Joran's blog post](https://experienced-sampler.netlify.app/post/stan-hierarchical-ar/).

The model is for each individual i and timepoint t,

y_it ~ normal(eta_it, sigma)
eta_it = (alpha_hat + alpha_i) + (beta_hat + beta_i) * (y_i[t-1])
[alpha_i, beta_i] ~ mvn([0, 0], Sigma)

That is we model y on an intercept and an autoregressive coefficient with varying intercepts and slopes over people.

### Data

We first set up the data simulation.

```{r}
#' Simulate ar(1) data
#' 
#' Adapted from <https://experienced-sampler.netlify.app/post/stan-hierarchical-ar/#testing>
#'
#' @param I number of individuals
#' @param t number of time points per individual
#' @param sigma residual standard deviation of observations
#' @param alpha_hat intercept mean
#' @param alpha_scale intercept standard deviation
#' @param beta_hat ar(1) slope mean
#' @param beta_scale ar(1) slope standard deviation
#'
#' @return a list of variables to send to Stan
#'
#' @examples simulate()
simulate <- function(
    I = 50, 
    t = 25, 
    sigma = 1, 
    alpha_hat = 4, 
    alpha_scale = 1, 
    beta_hat = 0.4, 
    beta_scale = 0.1
) {
  
  # Define data
  N <- I*t # total sample size
  individual <- rep(1:I, each = t)
  time <- rep(1:t, I)
  alphas <- rnorm(I, alpha_hat, alpha_scale) # person-specific intercepts
  betas <- rnorm(I, beta_hat, beta_scale) # person-specific slopes
  for (i in 1:I) {
    # The while loop avoids non-stationary AR processes
    # See Hamilton  pg. 259
    while(betas[i] <= -1 | betas[i] >= 1) {
      betas[i] <- rnorm(1, beta_hat, beta_scale)
    }
  }
  
  # Determine first observations for everyone. The variance for this first 
  # observation is different than for the subsequent ones and so it needs to be 
  # samples separately
  IndT1 <- match(unique(individual), individual)
  
  # Determine variance at first measurement for everyone 
  # (depends on their AR-parameter)
  sigmaT1 <- rep(NA, I)
  
  for (k in 1:I) {
    sigmaT1[k] <- sigma/(1-((betas[k])^2))
  }
  
  # First create storage matrices for non-centered and centered y-scores.
  # We need centered values, because of we use person-centered values as predictors, 
  # alpha will be equal to individual means instead of individual intercepts 
  # which are less informative.
  Y <- rep(NA, N)
  Yc <- rep(NA, N)
  
  # Draw first observation for each individual first
  for (l in 1:I) {
    Y[IndT1[l]] <- rnorm(1, alphas[l], sigmaT1[l])
    Yc[IndT1[l]] <-  Y[IndT1[l]] - alphas[l]
  }
  
  # Draw subsequent observations
  for (m in 1:N) {
    # This if statement makes sure I don't try to predict a persons first 
    # observation which is impossible there is no measurement before the first 
    # observation and so no predictor values for that observation
    if (time[m]>1) {
      Y[m] <- rnorm(1, (alphas[individual[m]] + betas[individual[m]]*Yc[m-1]), sigma)
      Yc[m] <-  Y[m] - alphas[individual[m]]
    }
  }
  
  return(
    list(
      I = I,
      T = t,
      N = N,
      sigma = sigma, 
      alpha_hat = alpha_hat, 
      alpha_scale = alpha_scale, 
      beta_hat = beta_hat, 
      beta_scale = beta_scale,
      individual = individual,
      time = time,
      y = Y
    )
  )
  
}
```

The function returns a list that we can pass to Stan. It also contains the data generation parameters.

```{r}
set.seed(31121)
dat <- simulate()
glimpse(simulate())
```

### Stan

Let us then compile and sample from the Stan model (`model-ar1.stan`) with cmdstanr

```{r}
#| output: false

path <- "cache/cmdstanr-example.rds"
if (!file.exists(path)) {
  model <- cmdstan_model("model-ar1.stan", compile = FALSE)
  model$format(
    canonicalize = list("deprecations"),
    overwrite_file = TRUE,
    backup = FALSE
  )
  model$compile()
  post_cmdstanr <- model$sample(
    data = dat, 
    adapt_delta = 0.99
  ) |> 
    as_draws_df()
  saveRDS(post_cmdstanr, path)
} else {
  post_cmdstanr <- readRDS(path)
}
```

Posterior summary:

```{r}
post_cmdstanr <- post_cmdstanr |> 
  select(
    alpha_hat_raw, alpha_scale_raw, 
    beta_hat, beta_scale, 
    sigma_raw
  ) |> 
  rename_with(~str_remove(., "_raw"))

summarize_draws(post_cmdstanr) |> 
  gt() |> 
  fmt_number(decimals = 2)
```

### brms

brms takes a data frame, so we convert the list here

```{r}
dat <- as_tibble(dat)
dat <- dat |> 
  mutate(yt1 = lag(y), .by = individual)
head(dat) |> 
  gt() |> 
  fmt_number(decimals = 2)
```

#### Model specification

We can specify this model using brms' nonlinear formulas. Note that we created the `yt1` variable (i.e. y[t-1]) above.

```{r}
#| output: false

bform <- bf(
  y ~ 0 + alpha + beta * (yt1 - alpha),
  alpha ~ 1 + (1 | individual),
  beta ~ 1 + (1 | individual),
  nl = TRUE
)
fit_brms <- brm(
  bform,
  data = dat,
  file = "cache/brm-example.rds"
)
```

We see that the estimated parameters are very close to coefficients from the Stan model

```{r}
post_brms <- as_draws_df(fit_brms) |> 
  select(
    alpha_hat = b_alpha_Intercept,
    alpha_scale = sd_individual__alpha_Intercept,
    beta_hat = b_beta_Intercept,
    beta_scale = sd_individual__beta_Intercept,
    sigma
  )

bind_rows(
  "Stan" = summarize_draws(post_cmdstanr),
  "brms" = summarize_draws(post_brms),
  .id = "Model"
) |> 
  arrange(variable, Model) |> 
  gt() |> 
  fmt_number(decimals = 2)
```

### Simulation

Above, we estimated the Stan and brms models once. Here, we evaluate whether they recover the specified parameters with a small simulation.

```{r}
path <- "cache/sim-univariate.rds"
if (!file.exists(path)) {
  # Ensure that models are compiled
  model_stan <- cmdstan_model("model-ar1.stan", compile = TRUE)
  fit_brms <- brm(
    bform,
    data = dat,
    chains = 0,
    threads = 1
  )
  
  # Define simulation outputs
  K <- 30
  out <- vector("list", length = K)
  
  # Parallelization scheme:
  # Each of two workers will launch a session that runs 4 chains in parallel
  # resulting in total 8 cores used
  plan(multisession, workers = 2)
  
  for (k in 1:K) {
    this_sample <- simulate()
    
    this_stan <- future({
      model_stan$sample(
        data = this_sample, 
        adapt_delta = 0.99, 
        parallel_chains = 4,
        iter_sampling = 2000,
        refresh = 0, 
        show_messages = FALSE
      )
    }, seed = TRUE)
    
    this_brms <- future({
      update(
        fit_brms, 
        newdata = as_tibble(this_sample) |> 
          mutate(yt1 = lag(y), .by = individual),
        control = list(adapt_delta = 0.99),
        cores = 4,
        iter = 2000,
        recompile = FALSE,
        refresh = 0,
        silent = 2
      )
    }, seed = TRUE)
    
    this_stan <- value(this_stan) 
    this_stan <- this_stan |> 
      as_draws_df() |> 
      select(
        alpha_hat_raw, alpha_scale_raw, 
        beta_hat, beta_scale, 
        sigma_raw
      ) |> 
      rename_with(~str_remove(., "_raw")) |> 
      summarize_draws()
    
    this_brms <- value(this_brms) 
    this_brms <- this_brms |> 
      as_draws_df() |> 
      select(
        alpha_hat = b_alpha_Intercept,
        alpha_scale = sd_individual__alpha_Intercept,
        beta_hat = b_beta_Intercept,
        beta_scale = sd_individual__beta_Intercept,
        sigma
      ) |> 
      summarize_draws()
    
    out[[k]] <- bind_rows(
      "Stan" = this_stan,
      "brms" = this_brms,
      .id = "model"
    )
  }
  
  out <- bind_rows(out, .id = "k")
  saveRDS(out, path)
} else {out <- readRDS(path)}
```

#### Results

```{r}
#| label: tbl-simulation

real_values <- tribble(
  ~variable, ~true,
  "sigma", 1, 
  "alpha_hat", 4, 
  "alpha_scale", 1, 
  "beta_hat", 0.4, 
  "beta_scale", 0.1
)
out |> 
  summarise(
    mean = str_glue("{number(mean(mean), .01)} ({number(sd(mean), .01)})"),
    .by = c(model, variable)
  ) |> 
  pivot_wider(
    names_from = model, values_from = mean
  ) |> 
  left_join(
    real_values
  ) |> 
  gt() |> 
  fmt_number(decimals = 1) |> 
  fmt_missing(missing_text = " ")
```

## Conclusion

This small simulation shows that brms perfectly recovers parameters of a simple univariate autoregressive latent variable model. The mean estimates over 30 simulation iterations were identical for brms and Stan to the second significant digit, and within MCSE of the true values.
